6단원 응용

🌀 1. 미로 찾기 알고리즘 (그래프 탐색 BFS)  - 186페이지 예
# 미로 찾기 문제: 시작점 → 도착점까지 가장 짧은 길 찾기
# 아이디어: 미로를 '그래프(꼭짓점과 선)'로 표현하고 BFS(큐)를 이용

미로를 그래프로 모델링하기
# 각 칸(알파벳)을 '꼭짓점(정점)'으로 보고
# 서로 이동할 수 있으면 '선(간선)'으로 연결한 표 (인접 리스트)
maze = {
    'a': ['e'],          # a에서 e로 갈 수 있어요
    'b': ['c', 'f'],     # b에서는 c와 f로
    'c': ['b', 'd'],     # c에서는 b, d로
    'd': ['c'],          # d에서는 c로만
    'e': ['a', 'i'],     # e에서는 a, i로
    'f': ['b', 'g', 'j'],# f에서는 b, g, j로
    'g': ['f', 'h'],     # g에서는 f, h로
    'h': ['g', 'l'],     # h에서는 g, l로
    'i': ['e', 'm'],     # i에서는 e, m으로
    'j': ['f', 'k', 'n'],# j에서는 f, k, n으로
    'k': ['j', 'o'],     # k에서는 j, o로
    'l': ['h', 'p'],     # l에서는 h, p로
    'm': ['i', 'n'],     # m에서는 i, n으로
    'n': ['m', 'j'],     # n에서는 m, j로
    'o': ['k'],          # o에서는 k로
    'p': ['l']           # p에서는 l로만 (도착 근처)
}

2) 너비우선탐색(BFS)으로 “가장 짧은 길” 찾기

큐(줄 서기 박스)에 “지금까지 온 길”을 통째로 넣어 두고,
앞에서 하나씩 꺼내 주변 칸을 이어 붙이며 도착을 가장 빨리 만나는 길을 찾아요.

from collections import deque

def solve_maze(g, start, end):
    """
    g     : 미로 그래프(딕셔너리)
    start : 출발 칸(예: 'a')
    end   : 도착 칸(예: 'p')
    return: 출발~도착까지 '지나간 칸의 문자열'(예: 'aeimnjfghlp')
    """

    # 1) 앞으로 **처리할 이동 경로**들을 보관하는 줄(큐)
    #    경로는 '문자열'로 저장 (예: "ae"는 a→e를 뜻함)
    qu = deque()

    # 2) 이미 큐에 넣어 본 칸들을 기억하는 '집합'
    #    같은 칸을 또 또 넣지 않게 해서 무한반복을 막아요
    visited = set()

    # 3) 출발 칸을 첫 경로로 큐에 넣고, 방문 표시도 해요
    qu.append(start)     # 경로: 'a'
    visited.add(start)   # 'a'는 방문 완료!

    # 4) 큐가 빌 때까지(더 볼 경로가 없을 때까지) 반복
    while qu:
        path = qu.popleft()   # 맨 앞 경로 하나 꺼내요
        now  = path[-1]       # 그 경로의 '마지막 칸'(지금 서있는 칸)

        # 5) 지금 칸이 도착칸이면, 그때의 경로가 '가장 짧은 길'!
        if now == end:
            return path

        # 6) 지금 칸에서 갈 수 있는 이웃 칸들을 하나씩 본다
        for nxt in g[now]:
            # 아직 큐에 넣어본 적(=방문) 없다면 새 경로를 만들어 큐에 넣기
            if nxt not in visited:
                qu.append(path + nxt)  # 기존 path 뒤에 nxt를 이어붙여 새 경로 생성
                visited.add(nxt)       # 방문 표시(다음부터는 중복 금지)

    # 7) 큐가 빌 때까지 못 찾았다면 길이 없는 것. 물음표로 알려줘요.
    return "?"

사용 예
print(solve_maze(maze, 'a', 'p'))  # 예시 출력: aeimnjfghlp


------진행 과정을 보여주는 디버그 버전--------
학습용으로, 큐에서 꺼낸 경로와 새로 넣는 경로들을 출력해 보는 함수예요.

def solve_maze_debug(g, start, end):
    from collections import deque
    qu = deque([start])
    visited = {start}
    step = 0

    print(f"[시작] 큐={list(qu)}  방문={visited}")
    while qu:
        step += 1
        path = qu.popleft()
        now  = path[-1]
        print(f"\n[{step}단계] 꺼낸 경로: {path}  (현재칸: {now})")

        if now == end:
            print(f"→ 도착 '{end}' 발견! 최단 경로={path}")
            return path

        for nxt in g[now]:
            if nxt not in visited:
                new_path = path + nxt
                qu.append(new_path)
                visited.add(nxt)
                print(f"  - 이웃 '{nxt}' ▶ 새 경로 넣기: {new_path}")
        print(f"  큐 상태={list(qu)}")

    print("길이 없어요 :(")
    return "?"

@@ 핵심 요약 (왜 이 방법이 ‘최단’일까?) @@

BFS는 가까운 칸부터 멀리 있는 칸 순서로 탐색해요.
큐에서 처음 도착 칸이 나오는 순간의 경로가 항상 가장 짧은 길이에요.
(먼 길은 큐 뒤쪽에 있어서 더 나중에야 꺼내지거든요!)

-------------------------------------------------------------------

 [ 가짜 동전 찾기 알고리즘 1 ]  - 하나씩 비교하기  - 188페이지 예제

아이디어는 “맨 왼쪽 동전(0번)”을 기준으로 잡고, 오른쪽 동전들을 하나씩 비교저울에 올려 보면서 가벼운 쪽을 찾는 방식이에요.

# ---------------------------------------------------------
# 가짜 동전 찾기(방법1: 하나씩 비교)
# ---------------------------------------------------------
# 준비: 동전은 0, 1, 2, ..., n-1 번까지 번호가 붙어 있다고 생각해요.
# 이 중 딱 1개만 '가짜'라서 무게가 더 가벼워요.
# 우리는 '비교저울'을 흉내 낸 함수 weigh(a,b,c,d)를 만들어
# a~b 구간의 동전 묶음 vs c~d 구간의 동전 묶음을 비교해요.
#   - 왼쪽(a~b)이 더 가벼우면  -1
#   - 오른쪽(c~d)이 더 가벼우면  1
#   - 두 쪽 무게가 같으면       0  을 돌려줍니다.
#
# 방법1의 전략:
#   1) 맨 왼쪽 동전(0번)을 기준으로 삼아요.
#   2) 1번부터 끝(right)까지 동전을 차례로 꺼내 0번과 비교해요.
#   3) 저울 결과가 '왼쪽이 가벼움'이면 0번이 가짜!
#      '오른쪽이 가벼움'이면 그 동전(i)이 가짜!
#      같으면 다음 동전으로 넘어가요.
#   4) 끝까지 모두 같으면(이론상 발생하지 않지만) -1을 반환해 예외로 두어요.
# ---------------------------------------------------------

def weigh(a, b, c, d):
    """
    a~b, c~d 두 묶음의 무게를 비교해 결과를 반환.
    여기서는 '학습/실험'을 위해 가짜 동전 위치를 코드 안에 직접 넣어두었어요.
    실전이라면 저울 장치와 연결된 함수가 되겠죠!

    반환값:
      -1  : 왼쪽(a~b) 묶음이 더 가볍다  -> 가짜가 왼쪽에 있다
       1  : 오른쪽(c~d) 묶음이 더 가볍다 -> 가짜가 오른쪽에 있다
       0  : 두 묶음 무게가 같다         -> 이 둘엔 가짜가 없다(또는 반대쪽에 있다)
    """
    fake = 29                 # << 예시: 가짜 동전의 '번호'를 29번이라고 가정
    # 가짜가 왼쪽 묶음 안에 있으면 왼쪽이 더 가벼우니 -1
    if a <= fake <= b:
        return -1
    # 가짜가 오른쪽 묶음 안에 있으면 오른쪽이 더 가벼우니 1
    if c <= fake <= d:
        return 1
    # 양쪽 모두에 가짜가 없으면(=두 묶음의 무게가 같으면) 0
    return 0

def find_fakecoin(left, right):
    """
    [방법1] 0번(가장 왼쪽) 동전과 나머지 동전들을 하나씩 비교해서
    가짜 동전의 '번호'를 찾아 반환합니다.

    매개변수:
      left  : 조사 시작 번호 (보통 0)
      right : 조사 끝 번호   (보통 n-1)

    반환값:
      가짜 동전의 번호 (정수)
      만약 찾지 못하면 -1 (이론상 1개 있다고 했으므로 거의 나오지 않음)
    """
    # 기준 동전: 맨 왼쪽 동전(여기서는 left 위치의 동전)
    # i를 left+1부터 right까지 한 칸씩 늘리며 반복
    for i in range(left + 1, right + 1):
        # 기준(left) vs i번 동전을 비교저울에 올려 본다
        result = weigh(left, left, i, i)

        # 결과 해석
        if result == -1:
            # 왼쪽(=기준 동전)이 가볍다 → 기준 동전이 가짜!
            return left
        elif result == 1:
            # 오른쪽(=i번 동전)이 가볍다 → i번이 가짜!
            return i
        # result가 0이면 두 동전 무게가 같으니 i는 진짜 → 계속 반복

    # 여기까지 왔다는 건 모든 비교가 '같다(0)'였다는 뜻.
    # 문제 설정상 '가짜는 반드시 1개'이므로 이 경우는 예외 처리로 -1
    return -1

# --- 실행 예시 -------
n = 100  # 동전이 100개(0 ~ 99번)
print(find_fakecoin(0, n - 1))  # 위에서 fake=29로 설정했으므로 29가 출력됩니다.

-----------------------------------------------------------------

 [ 가짜 동전 찾기 알고리즘 2 ]  - 반씩 그룹으로 나누어 비교하기  - 189페이지 예제


# 가짜 동전의 위치를 판단하는 함수
def weigh(a, b, c, d):
    fake = 29  # 가짜 동전의 인덱스를 정답으로 임의 지정 (예: 29번이 가짜 동전)

    # 가짜 동전이 왼쪽 그룹에 있으면 -1 반환
    if a <= fake and fake <= b:
        return -1

    # 가짜 동전이 오른쪽 그룹에 있으면 1 반환
    if c <= fake and fake <= d:
        return 1

    # 어느 쪽에도 없으면 (즉, 남은 1개가 가짜면) 0 반환
    return 0


# 가짜 동전의 위치를 찾는 재귀 함수
def find_fakecoin(left, right):
    # 종료 조건: 한 개만 남았을 경우 그게 가짜 동전
    if left == right:
        return left

    # 전체 범위를 반으로 나누기 (홀수일 경우, 마지막 하나는 남게 됨)
    half = (right - left + 1) // 2

    # 왼쪽 그룹 범위
    g1_left = left
    g1_right = left + half - 1

    # 오른쪽 그룹 범위
    g2_left = left + half
    g2_right = g2_left + half - 1

    # weigh 함수를 이용해 두 그룹의 무게 비교
    result = weigh(g1_left, g1_right, g2_left, g2_right)

    # 왼쪽 그룹이 가볍다면 → 왼쪽에 가짜 동전 있음 → 왼쪽 그룹으로 재귀
    if result == -1:
        return find_fakecoin(g1_left, g1_right)

    # 오른쪽 그룹이 가볍다면 → 오른쪽 그룹으로 재귀
    elif result == 1:
        return find_fakecoin(g2_left, g2_right)

    # 양쪽 그룹 무게가 같다면 → 남은 1개의 동전이 가짜
    else:
        return right


# 동전 개수 설정
n = 100

# 0번부터 99번까지 동전 중 가짜 동전의 위치 찾기
print(find_fakecoin(0, n - 1))  # 예: 29 출력


🧠 요약 포인트
weigh()는 실제 저울 역할 (가짜가 어디 있는지 비교)
find_fakecoin()은 분할 정복과 재귀를 이용해 가짜를 찾음
half를 기준으로 그룹을 나누고, 결과에 따라 해당 그룹만 재귀적으로 탐색
시간복잡도는 O(log n) → 매우 효율적!
