[기본1] 1부터 n까지 합 (반복문 / 가우스 공식)
def sum_loop(n):
    """
    1부터 n까지의 합을 '하나씩 더해서' 구하는 함수
    예) n=4라면 1+2+3+4 = 10
    """
    s = 0                 # 지금까지 더한 결과(합계)를 담을 통장 = 0원부터 시작!
    for i in range(1, n+1):  # i가 1,2,3,...,n까지 차례로 바뀌며 반복
        s += i            # 통장(s)에 i원을 저축(더하기)
    return s              # 다 더한 뒤 통장에 있는 돈(합계)을 돌려줌


def sum_gauss(n):
    """
    가우스 공식: 1부터 n까지의 합 = n*(n+1)//2
    // : 정수 나눗셈(몫만 취함) - 초등 나눗셈의 '몫'과 같아요!
    """
    return n * (n + 1) // 2


# 사용 예시(둘 다 55가 나와야 정답!)
print(sum_loop(10), sum_gauss(10))  # 55 55

👉 핵심 포인트
sum_loop는 “한 칸씩 계단 오르기”, sum_gauss는 “엘리베이터 타고 한 번에 올라가기” 비유로 설명할 수 있어요.

🎯 보충 미션

짝수만 더하기(1+3+5+…은 홀수합, 2+4+6+…은 짝수합) 함수를 만들어 보기.

--------------------------------------------------------------------


[기본2] 최대값 찾기
def find_max(a):
    """
    리스트 a 안에서 '가장 큰 수'를 찾아 돌려주는 함수
    a는 적어도 1개 이상의 수를 가지고 있다고 약속!
    """
    m = a[0]           # 일단 첫 번째 수를 '임시 우승자'로 세움
    for x in a[1:]:    # 두 번째부터 끝까지 한 명씩 도전자 등장
        if x > m:      # 도전자가 임시 우승자보다 크면
            m = x      # 우승자 바꾸기!
    return m           # 마지막까지 남은 우승자가 진짜 최대값


# 사용 예시(정답: 93)
print(find_max([18, 93, 20, 33, 58, 7, 32, 41]))


👉 핵심 포인트

“지금까지 최고 기록”을 계속 갈아치우는 방식이에요.

🎯 보충 미션

“최대값의 위치(인덱스)”도 함께 돌려주는 함수 만들기.

--------------------------------------------------------------------


[기본3] 동명이인 찾기(리스트 → 집합)
def find_same_name(names):
    """
    이름 목록(names)에서 '두 번 이상' 나온 이름들만 골라 '집합(set)'으로 돌려줌
    집합(set)은 중복을 자동으로 없애줘요.
    """
    count = {}  # 이름별 등장 횟수를 기록하는 '이름표 사전'
    for nm in names:
        # count에 nm가 없으면 0으로 시작, 있으면 기존 값에 +1
        count[nm] = count.get(nm, 0) + 1

    # 횟수가 2 이상인 이름만 모아서 집합으로!
    return {nm for nm, c in count.items() if c >= 2}


# 사용 예시(정답: {'Tom'})
print(find_same_name(["Tom", "Jerry", "Mike", "Tom"]))


👉 핵심 포인트

dict.get(키,기본값)은 “없으면 기본값부터 시작”이라는 뜻.

결과를 set으로 주는 이유: 같은 이름을 한 번만 보여 주려고요.

🎯 보충 미션

대소문자를 무시하고(예: 'tom'과 'Tom'을 같은 이름으로) 동명이인 찾기.

--------------------------------------------------------------------


[기본4] 최대공약수(GCD, 유클리드 호제법)
def gcd(a, b):
    """
    최대공약수: a와 b를 '둘 다 나눌 수 있는' 가장 큰 수
    유클리드 호제법: (a, b)의 최대공약수 = (b, a%b)의 최대공약수
    b가 0이 되면 a가 답!
    """
    while b != 0:       # b가 0이 될 때까지 계속
        a, b = b, a % b # 큰 수를 작은 수로 나눠 '나머지'를 다음 b로
    return a             # b가 0이면 a가 최대공약수


# 사용 예시(정답: 12)
print(gcd(60, 24))


👉 핵심 포인트

“나머지가 0이 될 때까지 계속 작게 작게 줄여가기” 전략.

🎯 보충 미션

세 수(a,b,c)의 최대공약수 구하기: gcd(gcd(a,b), c)로 단계적으로!



[기본5] 최소공배수(LCM)
def lcm(a, b):
    """
    최소공배수: a와 b가 '같이 만나는' 가장 작은 배수
    공식: a*b = gcd(a,b) * lcm(a,b)  ⇒  lcm = a*b // gcd(a,b)
    """
    from math import gcd as _g
    return a * b // _g(a, b)


# 사용 예시(정답: 36)
print(lcm(12, 18))


👉 핵심 포인트

“공약수로 겹치는 부분을 한 번만 곱해 주는” 생각이에요.

🎯 보충 미션

여러 수의 LCM 구하기: lcm(lcm(a,b), c) 식으로 차례대로.

--------------------------------------------------------------------

[기본6] 피보나치 수열 (재귀 / 반복)
def fibo_rec(n):
    """
    재귀 버전: f(0)=0, f(1)=1, f(n)=f(n-1)+f(n-2)
    스스로를 부르는(재귀) 정의 그대로 코딩!
    ※ 단, n이 커지면 너무 느려져요(같은 계산을 반복).
    """
    if n <= 1:          # f(0)=0, f(1)=1
        return n
    return fibo_rec(n-1) + fibo_rec(n-2)


def fibo_it(n):
    """
    반복 버전: 빠르고 효율적
    a,b가 '연속 두 항'을 뜻함. 매번 다음 항으로 업데이트!
    """
    a, b = 0, 1         # f(0)=0 → a, f(1)=1 → b
    for _ in range(n):  # n번 만큼 앞으로 전진
        a, b = b, a + b # 새 a는 옛 b, 새 b는 둘의 합
    return a            # n번 전진 후의 a가 f(n)


# 사용 예시(둘 다 55)
print(fibo_rec(10), fibo_it(10))


👉 핵심 포인트

“정의는 재귀가 예쁘고, 실전은 반복이 빠르다!”

🎯 보충 미션

n이 큰 값에서도 빠르게 동작하도록 “메모이제이션(값 저장)” 적용해 보기.

--------------------------------------------------------------------

[심화] 하노이의 탑 (이동 순서 출력)
def hanoi(n, a, b, c):
    """
    원반 n개를 막대 a에서 막대 c로 옮기기(보조막대 b 사용)
    규칙:
      1) 한 번에 한 개만 옮긴다.
      2) 큰 원반은 항상 작은 원반 아래에 있어야 한다.
    아이디어(재귀):
      - 위에 n-1개를 a→b로 옮긴다(임시로 치우기).
      - 가장 큰 1개를 a→c로 옮긴다(목표 위치로).
      - 이제 b에 있던 n-1개를 c 위로 b→c로 옮긴다(정리하기).
    """
    if n == 1:                 # 원반이 1개면 바로 옮기고 끝!
        print(a, '→', c)
        return
    hanoi(n-1, a, c, b)        # 1단계: 윗부분 치우기
    print(a, '→', c)           # 2단계: 가장 큰 원반 옮기기
    hanoi(n-1, b, a, c)        # 3단계: 치운 것 다시 쌓기


# 사용 예시: 원반 3개, A→C
# 이동 횟수는 항상 2^n - 1 (여기선 7번)
hanoi(3, 'A', 'B', 'C')


👉 체크 포인트

“움직임의 개수 = 2^n - 1” 을 실험으로 확인해 보세요.


🎯 보충 미션

이동 횟수만 돌려주는 hanoi_count(n) 함수 만들어 보기(정답은 2**n - 1).

빠른 확인용 미니 테스트
assert sum_loop(10) == 55 and sum_gauss(10) == 55
assert find_max([1,9,3]) == 9
assert find_same_name(["a","b","a"]) == {"a"}
assert gcd(60,24) == 12
assert lcm(12,18) == 36
assert fibo_it(10) == 55
