
update-alternatives를 사용하여 기본 웹 브라우저를 확인하고, 
chromium-browser가 기본값인지 확인하세요.
다음 명령어를 사용해 기본값 설정을 수정할 수 있습니다
sudo update-alternatives --config x-www-browser



chromium-browser를 하드웨어 가속 없이 실행하도록 설정

import subprocess
import time
import tensorflow as tf
import numpy as np
import cv2
from tensorflow.keras.models import load_model
from PIL import Image
import board
import neopixel
from selenium import webdriver
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# 네오픽셀 설정
LED_PIN = board.D18  # 사용 중인 핀을 설정합니다.
LED_COUNT = 3  # LED 개수를 설정합니다.
pixels = neopixel.NeoPixel(LED_PIN, LED_COUNT)

# 모델 및 레이블 파일 절대 경로 설정
model_path = '/home/pi/cos/converted_keras/keras_model.h5'
labels_path = '/home/pi/cos/converted_keras/labels.txt'

# 모델 로드
model = load_model(model_path)

# 클래스 이름 로드
with open(labels_path, 'r') as f:
    class_names = [line.strip() for line in f.readlines()]

# 이미지 전처리 함수
def preprocess_image(image):
    image = Image.fromarray(image)
    image = image.resize((224, 224))
    image = np.array(image) / 255.0
    image = np.expand_dims(image, axis=0)
    return image

# Firefox 옵션 설정 (헤드리스 모드로 실행하지 않음)
options = webdriver.FirefoxOptions()
#options.add_argument("--headless")  # 헤드리스 모드를 사용하지 않도록 주석 처리

# Firefox 서비스 설정 (geckodriver의 경로 지정)
service = Service(executable_path="/usr/local/bin/geckodriver")

# 웹캠 초기화
camera_index = 0
cap = cv2.VideoCapture(camera_index)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)

if not cap.isOpened():
    print("웹캠을 열 수 없습니다.")
    exit()

# 메인 루프
while True:
    ret, frame = cap.read()
    if not ret:
        print("프레임을 읽을 수 없습니다.")
        break

    # 이미지 전처리
    image = preprocess_image(frame)

    # 예측 수행
    predictions = model.predict(image)
    predicted_class = class_names[np.argmax(predictions)]

    # 결과 출력
    cv2.putText(frame, f'Predicted: {predicted_class}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
    cv2.imshow('Webcam', frame)

    # 예측된 표정에 따른 동작
    try:
        if predicted_class == 'joy':
            pixels.fill((0, 255, 0))
            search_url = "https://www.youtube.com/results?search_query=행복하게+해주는+노래"
        elif predicted_class == 'sad':
            pixels.fill((0, 0, 255))
            search_url = "https://www.youtube.com/results?search_query=위로해주는+노래"
        elif predicted_class == 'angry':
            pixels.fill((255, 0, 0))
            search_url = "https://www.youtube.com/results?search_query=화났을때+듣는+노래"
        elif predicted_class == 'emotionless':
            pixels.fill((255, 255, 0))
            search_url = "https://www.youtube.com/results?search_query=신나게+해주는+노래"

        pixels.show()

        # YouTube 검색 및 첫 번째 비디오 자동 재생
        driver = webdriver.Firefox(options=options, service=service)
        driver.get(search_url)

        # 첫 번째 비디오 클릭
        first_video = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="video-title"]'))
        )
        first_video.click()

        # 비디오가 10초 동안 재생되도록 대기
        time.sleep(10)

        # 브라우저 닫기
        driver.quit()

        # LED 초기화
        pixels.fill((0, 0, 0))
        pixels.show()

    except Exception as e:
        print(f"Error opening or playing video: {e}")

    # 'q' 키를 누르면 종료
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# 웹캠 및 창 닫기
cap.release()
cv2.destroyAllWindows()

