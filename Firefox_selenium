

sudo apt-get update
sudo apt-get install firefox-esr


(64비트)

wget https://github.com/mozilla/geckodriver/releases/download/v0.33.0/geckodriver-v0.33.0-linux-aarch64.tar.gz
tar -xzvf geckodriver-v0.33.0-linux-aarch64.tar.gz
sudo mv geckodriver /usr/local/bin/
sudo chmod +x /usr/local/bin/geckodriver

geckodriver --version


Chrome 대신 Firefox를 사용하려면 아래와 같이 코드를 약간 수정해 주시면 됩니다.

import tensorflow as tf
import time
import numpy as np   
import cv2
from tensorflow.keras.models import load_model
from PIL import Image
import board
import neopixel
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.firefox.service import Service
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# 네오픽셀 설정
LED_PIN = board.D18  # 사용 중인 핀을 설정합니다.
LED_COUNT = 3  # LED 개수를 설정합니다.
pixels = neopixel.NeoPixel(LED_PIN, LED_COUNT)

# 모델 및 레이블 파일 절대 경로 설정
model_path = '/home/pi/converted_keras/keras_model.h5'  # 라즈베리파이에 맞게 경로 수정
labels_path = '/home/pi/converted_keras/label.txt'

# 모델 로드
model = load_model(model_path)

# 클래스 이름 로드
with open(labels_path, 'r') as f:
    class_names = [line.strip() for line in f.readlines()]

# 이미지 전처리 함수
def preprocess_image(image):
    image = Image.fromarray(image)
    image = image.resize((224, 224))  # 모델의 입력 크기에 맞게 이미지 크기 조정
    image = np.array(image) / 255.0  # 스케일링
    image = np.expand_dims(image, axis=0)  # 배치 차원 추가
    return image

# Firefox 드라이버 설정
options = Options()
options.add_argument("--headless")  # 브라우저를 백그라운드에서 실행
options.add_argument("--no-sandbox")

# Geckodriver 경로 설정
service = Service("/usr/local/bin/geckodriver")
driver = webdriver.Firefox(service=service, options=options)

# 웹캠 초기화 및 해상도 설정
camera_index = 0
cap = cv2.VideoCapture(camera_index)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)  # 카메라 해상도 조정 (예: 320x240)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)

if not cap.isOpened():
    print("웹캠을 열 수 없습니다.")
    exit()

while True:
    ret, frame = cap.read()
    if not ret:
        print("프레임을 읽을 수 없습니다.")
        break

    # 이미지 전처리
    image = preprocess_image(frame)

    # 예측 수행
    predictions = model.predict(image)
    predicted_class = class_names[np.argmax(predictions)]

    # 결과 출력
    cv2.putText(frame, f'Predicted: {predicted_class}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
    cv2.imshow('Webcam', frame)

    # 예측된 표정에 따른 동작
    if predicted_class == 'joy':
        pixels.fill((0, 255, 0))  # 초록색
        driver.get("https://www.youtube.com/results?search_query=행복하게+해주는+노래")
    elif predicted_class == 'sad':
        pixels.fill((0, 0, 255))  # 파란색
        driver.get("https://www.youtube.com/results?search_query=위로해주는+노래")
    elif predicted_class == 'angry':
        pixels.fill((255, 0, 0))  # 빨간색
        driver.get("https://www.youtube.com/results?search_query=화났을때+듣는+노래")
    elif predicted_class == 'emotionless':
        pixels.fill((255, 255, 0))  # 노란색
        driver.get("https://www.youtube.com/results?search_query=신나게+해주는+노래")

    pixels.show()
    time.sleep(1)
    pixels.fill((0, 0, 0))  # LED 끄기
    pixels.show()

    # 유튜브 영상 재생 처리
    try:
        video = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, '//*[@id="video-title"]'))
        )
        video.click()

        # 비디오 페이지가 로드될 때까지 대기
        time.sleep(60)  # 페이지가 로드되고 비디오가 재생될 시간을 줌
        driver.quit()
        print("Browser closed.")
    except Exception as e:
        print(f"Error playing video: {e}")

    # 'q' 키를 누르면 종료
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# 웹캠 및 창 닫기
cap.release()
cv2.destroyAllWindows()
