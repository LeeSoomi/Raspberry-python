0) 하드웨어/배선 (피코 자동차)

SSD1306 I²C OLED: 주소 0x3C, 128×64

배선: SDA→GP0, SCL→GP1, VCC→3V3(OUT), GND→GND

--------------------------

1) 피코(자동차) — 수신/표시 코드
# car_view_filtered.py  (Pico 2 W / MicroPython)
from micropython import const
from machine import Pin, I2C
from ssd1306 import SSD1306_I2C
import bluetooth, utime

CAR_ID="CAR - 01"
I2C_SCL, I2C_SDA, OLED_ADDR = 1, 0, 0x3C
SCAN_INT_US, SCAN_WIN_US = const(50_000), const(50_000)
IRQ_SCAN_RESULT = getattr(bluetooth, "IRQ_SCAN_RESULT", const(5))
WAIT_MS = const(6000)

i2c  = I2C(0, scl=Pin(I2C_SCL), sda=Pin(I2C_SDA), freq=400_000)
oled = SSD1306_I2C(128, 64, i2c, addr=OLED_ADDR)

def cx(s): return max(0, (128-len(s)*8)//2)

def draw_wait():
    oled.fill(0); oled.text(CAR_ID, cx(CAR_ID), 0)
    oled.text("WAIT...", cx("WAIT..."), 24); oled.show()

def draw_state(dir_, sec, tchar="-"):
    line2 = "{} {:>2}s".format((tchar or "-")[:1].upper(), sec)
    line3 = "DIR:{}".format(dir_ or "-")
    oled.fill(0); oled.text(CAR_ID, cx(CAR_ID), 0)
    oled.text(line2, cx(line2), 24)
    oled.text(line3, cx(line3), 40)
    oled.show()

def parse_kv(s):
    d={}
    for kv in s.split("|"):
        if ":" in kv:
            k,v=kv.split(":",1); d[k]=v
    if not d: return None
    dir_ = d.get("DIR", d.get("D", ""))
    sec  = d.get("RT",  d.get("S", ""))
    if not (dir_ and sec.isdigit()): return None
    tchar = d.get("T", d.get("PH",""))[:1] if d.get("T", d.get("PH","")) else "-"
    q     = int(d.get("Q", d.get("ACK","0")) or 0)
    return {"DIR":dir_, "SEC":int(sec), "TCHAR":tchar, "Q":q}

ble = bluetooth.BLE(); ble.active(True)
last_ms = 0; last_info = None

def iter_ad(adv):
    i,L=0,len(adv)
    while i+1<L:
        ln=adv[i]; 
        if ln==0: break
        t=adv[i+1]; v=adv[i+2:i+1+ln]
        yield t,v; i+=1+ln

def irq(event, data):
    global last_ms, last_info
    if event==IRQ_SCAN_RESULT:
        _,_,_,_,adv_data = data
        adv = bytes(adv_data)
        # 1) Service Data 0xFFFF
        for t,v in iter_ad(adv):
            if t==0x16 and len(v)>=2 and (v[0] | (v[1]<<8))==0xFFFF:
                info = parse_kv(v[2:].decode("utf-8","ignore"))
                if info: last_info=info; last_ms=utime.ticks_ms(); return
        # 2) Local/Short Name
        for t,v in iter_ad(adv):
            if t in (0x09,0x08):
                info = parse_kv(v.decode("utf-8","ignore"))
                if info: last_info=info; last_ms=utime.ticks_ms(); return

ble.irq(irq)
ble.gap_scan(0, SCAN_INT_US, SCAN_WIN_US, True)  # 액티브 스캔
draw_wait()

while True:
    now = utime.ticks_ms()
    if last_info and utime.ticks_diff(now,last_ms)<WAIT_MS:
        draw_state(last_info["DIR"], last_info["SEC"], last_info["TCHAR"])
    else:
        draw_wait()
    utime.sleep_ms(100)

---------------------------------------------
실행: Thonny에서 이 파일을 열고 Run(F5) → OLED에 CAR - 01 / WAIT... 보이면 대기 정상.

---------------------------------

2) 라즈베리파이5(중앙) — 준비
sudo apt update
sudo apt install -y bluetooth bluez python3-pip
pip3 install --upgrade dbus-next
# (루트 없이 실행할 거면) 파이썬에 BT 권한 부여
sudo setcap cap_net_raw,cap_net_admin+eip $(readlink -f $(which python3))
# 블루투스 서비스 확인
systemctl status bluetooth
중요: 기존에 bluetoothctl advertise on으로 다른 광고가 돌고 있으면 끄는 걸 권장(충돌 방지).

--------------------------------------

3) 라즈베리파이5(중앙) — 광고 runner (Service Data 0xFFFF)

아래 파일을 파이에 저장(예: /home/pi/ble_adv_service_data_runner.py):

# ble_adv_service_data_runner.py
import asyncio, sys
from dbus_next.aio import MessageBus
from dbus_next.message import Message
from dbus_next.constants import MessageType

ADAPTER = "hci0"

def mk_props(payload: str):
    data = payload.encode("utf-8")
    return {
        "Type": "peripheral",
        "LocalName": "Pi5",
        "ServiceData": { "ffff": bytes(data) },  # uuid16: 0xffff
        "IncludeTxPower": False,
        "Discoverable": True,
        "Timeout": 0,
        "MinInterval": 160,  # 100ms
        "MaxInterval": 320,  # 200ms
    }

class LEAdvertisement:
    PATH = "/com/example/adv0"
    IFACE = "org.bluez.LEAdvertisement1"
    def __init__(self, props): self.props = props
    def get_properties(self): return { self.IFACE: self.props }
    async def Release(self): pass

async def register(bus, props):
    adv = LEAdvertisement(props)
    bus.export(LEAdvertisement.PATH, adv)
    msg = Message(destination="org.bluez",
                  path=f"/org/bluez/{ADAPTER}",
                  interface="org.bluez.LEAdvertisingManager1",
                  member="RegisterAdvertisement",
                  signature="oa{sv}",
                  body=[LEAdvertisement.PATH, {}])
    reply = await bus.call(msg)
    if reply.message_type == MessageType.ERROR:
        raise RuntimeError("RegisterAdvertisement failed")
    return adv

async def unregister(bus):
    msg = Message(destination="org.bluez",
                  path=f"/org/bluez/{ADAPTER}",
                  interface="org.bluez.LEAdvertisingManager1",
                  member="UnregisterAdvertisement",
                  signature="o",
                  body=["/com/example/adv0"])
    try: await bus.call(msg)
    except: pass

async def main():
    bus = await MessageBus(system=True).connect()
    adv_obj = None
    while True:
        line = sys.stdin.readline()
        if not line: break
        payload = line.strip()
        try:
            if adv_obj: await unregister(bus)
            props = mk_props(payload)
            adv_obj = await register(bus, props)
            print("ADV->", payload, flush=True)
        except Exception as e:
            print("ADVERR", e, flush=True)

if __name__ == "__main__":
    asyncio.run(main())

-----------------------------

4) 라즈베리파이5(중앙) — 컨트롤러(스캐닝 콜백/상태머신 + runner 내부 실행)

아래 파일을 저장(예: /home/pi/controller_sim.py).
핵심: Broadcaster가 runner를 내부에서 자동 실행하고, 매초 payload(RT/DIR/Q/T)를 파이프로 전달함

from collections import deque
import time, json, os, re, threading, subprocess, sys
import subprocess, sys, os


# central_scan이 없다면 패스(필요시 직접 구현/연결)
try:
    import central_scan
except ImportError:
    class central_scan:
        @staticmethod
        def start_scan(cb, target_dir="N"):
            print("[INFO] central_scan 없음: 스캔 생략")

# ===== 고정 방향/상태 파라미터 =====
TARGET_DIR = "N"
PHASE_MAP  = {"N":"NS","S":"NS","E":"EW","W":"EW"}
G_BASE, G_EXT = 5, 8
YELLOW, ALL_RED = 2, 13
DECISION_WINDOW_SEC = 15.0

REG_PATH = "car_names.json"
IDX_PAT  = re.compile(r"차량\s*(\d+)")

def _load_reg():
    if os.path.exists(REG_PATH):
        try:
            with open(REG_PATH, "r", encoding="utf-8") as f:
                d = json.load(f)
                return d if isinstance(d, dict) else {}
        except: pass
    return {}

def _next_idx(reg):
    mx = 0
    for name in reg.values():
        m = IDX_PAT.search(name)
        if m:
            try: mx = max(mx, int(m.group(1)))
            except: pass
    return mx + 1

def name_for_uid(uid_hex, reg):
    uid_hex = uid_hex.upper()
    if uid_hex in reg: return reg[uid_hex]
    idx = _next_idx(reg)
    label = f"C  차량{idx}  UID3={uid_hex}"
    reg[uid_hex] = label
    try:
        with open(REG_PATH, "w", encoding="utf-8") as f:
            json.dump(reg, f, ensure_ascii=False, indent=2)
    except: pass
    return label

# ===== 스레드 세이프 ACK 버퍼 =====
class AckBus:
    def __init__(self):
        self.buf = deque()
        self.lock = threading.Lock()
    def push(self, direction, uid_hex):
        with self.lock:
            self.buf.append((time.time(), direction, uid_hex.upper()))
    def recent_uids(self, direction, window_sec):
        now = time.time()
        cut = now - window_sec - 1.0
        with self.lock:
            while self.buf and self.buf[0][0] < cut:
                self.buf.popleft()
            return {u for (t,d,u) in self.buf if d==direction and (now - t) <= window_sec}

# ===== Broadcaster: runner를 내부에서 띄워 ServiceData로 광고 =====
class Broadcaster:
    def __init__(self,
                 runner_path="/home/codestudio/COS/ble_adv_service_data_runner.py",
                 python_exec="/home/codestudio/COS/bleenv/bin/python3"):
        self.runner_path = runner_path
        self.python_exec = python_exec
        self.proc = None
        self._last_payload = None
        self._start_runner()

    def _start_runner(self):
        # 이미 살아있으면 재시작 안 함
        if self.proc and self.proc.poll() is None:
            return
        # 환경: 가상환경 내 python으로 runner 실행
        self.proc = subprocess.Popen(
            [self.python_exec, self.runner_path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            env={**os.environ, "PYTHONUNBUFFERED": "1"}  # 즉시 flush
        )
        print("[BT] runner started")

    def advertise(self, ph, dir_letter, state, rt, g, q_flag):
        payload = f"RT:{rt}|DIR:{dir_letter}|Q:{int(q_flag)}|T:{state[:1]}"
        if payload == self._last_payload:
            return
        if self.proc is None or self.proc.poll() is not None:
            self._start_runner()
        try:
            self.proc.stdin.write(payload + "\n")
            self.proc.stdin.flush()
            self._last_payload = payload
            # 필요하면 runner의 stdout 라인을 읽어 디버그
            # print(self.proc.stdout.readline().strip())
            print("[ADV]", payload)
        except BrokenPipeError:
            self._start_runner()

# ===== 상태머신 컨트롤러 =====
class Controller:
    def __init__(self):
        self.bus = AckBus()
        self.bc  = Broadcaster()
        self.dir = TARGET_DIR
        self.state = "BOOT"
        self.rt = 0
        self.g_alloc = G_BASE
        self.accept_acks = False
        self.registry = _load_reg()

    def on_car_seen(self, direction, uid_hex):
        if direction != self.dir: return
        if not self.accept_acks:  # GREEN 동안은 무시
            return
        self.bus.push(direction, uid_hex)

    def _window_uids(self):
        return self.bus.recent_uids(self.dir, DECISION_WINDOW_SEC)

    def start_green(self):
        uids = self._window_uids()
        self.g_alloc = G_EXT if len(uids) >= 3 else G_BASE
        self.rt = self.g_alloc
        names = ", ".join([name_for_uid(u, self.registry) for u in sorted(uids)]) or "-"
        print(f"[DBG] wait=15s cars={len(uids)} nextG={self.g_alloc} names=[{names}]")

    def next_phase(self):
        if self.state == "BOOT":
            self.state = "GREEN"; self.start_green()
        elif self.state == "GREEN":
            self.state, self.rt = "YELLOW", YELLOW
        elif self.state == "YELLOW":
            self.state, self.rt = "RED", ALL_RED
        else:
            self.state = "GREEN"; self.start_green()

    def tick(self):
        if self.rt <= 0:
            self.next_phase()
        self.accept_acks = (self.state != "GREEN")  # GREEN 제외 대기 구간에서 Q=1
        ph = PHASE_MAP[self.dir]
        self.bc.advertise(ph, self.dir, self.state, self.rt, self.g_alloc, self.accept_acks)
        uids = self._window_uids()
        names = ", ".join([name_for_uid(u, self.registry) for u in sorted(uids)]) or "-"
        print(f"{self.state:<6} RT:{self.rt}s  cars:{len(uids)}  names:[{names}]")
        self.rt -= 1

def run():
    ctrl = Controller()
    try:
        central_scan.start_scan(ctrl.on_car_seen, target_dir=TARGET_DIR)
    except Exception as e:
        print("[WARN] scan disabled:", e)
    try:
        while True:
            ctrl.tick()
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nBye")

if __name__ == "__main__":
    run()
----------------------

실행:
실행 순서 (전체)

피코(자동차): car_view_filtered.py 실행 → OLED WAIT...

라즈베리파이(중앙): (선택) 충돌 방지 위해 기존 광고 끄기
bluetoothctl
[bluetooth]# advertise off
[bluetooth]# quit


라즈베리파이(중앙): 컨트롤러 실행
/home/codestudio/COS/bleenv/bin/python3 /home/pi/controller_sim.py


콘솔에 [BT] runner started / [ADV] RT:..|DIR:..|Q:..|T:.. 로그가 나오면 광고 송출 중

피코 OLED: G 05s / DIR:N 형태로 갱신되면 성공
-----------------------------------

자동 실행(부팅 시)
Pico에 아래 내용으로 main.py 파일을 추가:
import car_view_filtered  # 파일을 import하면 내부의 while 루프가 바로 실행됨
