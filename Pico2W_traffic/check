1) 시스템 의존성(bluepy 빌드용) 설치
sudo apt-get update
sudo apt-get install -y libglib2.0-dev python3-dev gcc

2) bluepy를 bleenv에 설치
/home/codestudio/bleenv/bin/pip install --upgrade pip setuptools wheel
/home/codestudio/bleenv/bin/pip install bluepy

3) 설치 확인
/home/codestudio/bleenv/bin/python -c "import sys, bluepy; print(sys.executable); print(bluepy.__file__)"


출력 경로가 /home/codestudio/bleenv/... 아래여야 정상.

4) 실행 (중요: 가상환경의 python을 sudo로 직접 지정)
sudo /home/codestudio/bleenv/bin/python /home/codestudio/COS/central_cycle.py
# 또는 인자:
sudo /home/codestudio/bleenv/bin/python /home/codestudio/COS/central_cycle.py 12 B
Bluetooth 초기화(한 번만):

sudo btmgmt -i hci0 power off
sudo btmgmt -i hci0 le on
sudo btmgmt -i hci0 bredr off
sudo btmgmt -i hci0 connectable off
sudo btmgmt -i hci0 power on


2) 중앙 스크립트 (광고↔스캔 교차) — 
0.8초간 광고로 피코에게 “Q:1” 트리거
2초간 스캔으로 피코들의 ACK(Service Data 0xFFFF) 수집
반복 루프

#!/usr/bin/env python3
# central_cycle.py
# - hci0로 Complete Local Name 광고(S:xx|D:yy|Q:1) -> Pico가 ACK광고
# - 즉시 스캔 전환하여 UUID 0xFFFF Service Data 파싱해 차량 ID/방향 표시

---------------------------------------------------------

#!/usr/bin/env python3
import subprocess, time, sys, signal
from bluepy.btle import Scanner

HCI = "hci0"
S_DEFAULT = 15
D_DEFAULT = "A"
ADV_ON_MS = 250      # 트리거는 짧게
SCAN_SEC  = 3.5      # 스캔은 넉넉히

def run(cmd):
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

def bytes_to_hex_args(b: bytes):
    # btmgmt advdata 는 "aa bb cc ..." 식으로 각 바이트를 별도 인자로 기대
    return [f"{x:02x}" for x in b]

def build_trigger_bytes(s, d, q=1):
    # Flags + Service Data(0x16, UUID=0xFFFE, ascii "S:..|D:..|Q:..")
    flags = bytes.fromhex("02 01 06")
    payload = f"S:{s}|D:{d}|Q:{q}".encode()
    sd = bytes([1 + 2 + len(payload), 0x16]) + b"\xfe\xff" + payload
    return flags + sd

# ---------- btmgmt path ----------
def adv_on_trigger_btmgmt(s, d, q=1):
    run(["sudo", "btmgmt", "-i", HCI, "power", "on"])
    run(["sudo", "btmgmt", "-i", HCI, "le", "on"])
    run(["sudo", "btmgmt", "-i", HCI, "bredr", "off"])
    run(["sudo", "btmgmt", "-i", HCI, "connectable", "off"])
    adv = build_trigger_bytes(s, d, q)
    args = ["sudo", "btmgmt", "-i", HCI, "advdata"] + bytes_to_hex_args(adv)
    out = run(args)
    if out.returncode != 0:
        print("[central] btmgmt advdata error:", out.stderr.strip())
        return False
    run(["sudo", "btmgmt", "-i", HCI, "advertising", "on"])
    print("[central] using btmgmt")
    return True

def adv_off_btmgmt():
    run(["sudo", "btmgmt", "-i", HCI, "advertising", "off"])

# ---------- raw HCI (fallback) ----------
def _hexlist(b: bytes):
    return [f"{x:02x}" for x in b]

def hci_cmd(ogf, ocf, payload_bytes):
    return run(["sudo", "hcitool", "-i", HCI, "cmd", ogf, ocf] + _hexlist(payload_bytes))

def adv_on_trigger_hci(s, d, q=1):
    run(["sudo", "hciconfig", HCI, "up"])
    # Set Advertising Parameters: min=max=0x00A0(100ms), type=0x03(ADV_NONCONN_IND)
    params = bytes.fromhex("A0 00 A0 00 03 00 00 00 00 00 00 00 07 00")
    hci_cmd("0x08", "0x0006", params)
    # Set Advertising Data
    adv = build_trigger_bytes(s, d, q)
    if len(adv) > 31:
        print("[central] adv payload too long:", len(adv)); return False
    pad = bytes([0x00] * (31 - len(adv)))
    hci_cmd("0x08", "0x0008", bytes([len(adv)]) + adv + pad)
    # Enable Advertising
    hci_cmd("0x08", "0x000A", bytes([0x01]))
    print("[central] using hcitool fallback")
    return True

def adv_off_hci():
    hci_cmd("0x08", "0x000A", bytes([0x00]))

# ---------- scan ACK (UUID 0xFFFF: 'P'+uid3+'|'+D) ----------
def parse_service_data_hex(hexstr):
    try:
        b = bytes.fromhex(hexstr)
        if len(b) < 2 or b[0:2] != b'\xff\xff': return None
        p = b[2:]
        if len(p) < 5 or p[0] != 0x50 or p[4] != 0x7C: return None
        uid3 = p[1:4].hex().upper()
        direction = chr(p[5]) if len(p) >= 6 else '?'
        return {"uid3": uid3, "direction": direction}
    except:
        return None

def scan_once(duration=SCAN_SEC):
    scanner = Scanner()
    devs = scanner.scan(duration)
    hits = []
    for d in devs:
        for (adtype, desc, value) in d.getScanData():
            if adtype == 0x16:
                parsed = parse_service_data_hex(value)
                if parsed:
                    hits.append({"mac": d.addr, "rssi": d.rssi, **parsed})
    return hits

def main():
    S = str(S_DEFAULT); D = D_DEFAULT
    if len(sys.argv) >= 2: S = sys.argv[1]
    if len(sys.argv) >= 3: D = sys.argv[2][:1]

    print(f"[central] cycle start on {HCI}  S:{S} D:{D} (Q=1, ADV {ADV_ON_MS}ms, SCAN {SCAN_SEC}s)")
    print("  Ctrl+C 로 종료")

    def handle_sigint(sig, frame):
        adv_off_btmgmt(); adv_off_hci()
        print("\n[central] stopped."); sys.exit(0)
    signal.signal(signal.SIGINT, handle_sigint)

    while True:
        ok = adv_on_trigger_btmgmt(S, D, 1)
        if not ok:
            ok = adv_on_trigger_hci(S, D, 1)

        time.sleep(ADV_ON_MS/1000.0)
        adv_off_btmgmt(); adv_off_hci()

        hits = scan_once(SCAN_SEC)
        if hits:
            seen = {}
            for h in hits:
                k = h["uid3"]
                if k not in seen or h["rssi"] > seen[k]["rssi"]:
                    seen[k] = h
            print(f"[central] ACK 수신 {len(seen)}대:")
            for k, h in seen.items():
                print(f"  - UID3={h['uid3']}  D={h['direction']}  RSSI={h['rssi']}  MAC={h['mac']}")
        else:
            print("[central] ACK 없음")

        time.sleep(0.5)

if __name__ == "__main__":
    main()
-------------------
